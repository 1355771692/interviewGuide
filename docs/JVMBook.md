## 第二章 Java内存区域与内存溢出异常
### 2.2运行时数据区域

运行时数据区域包含以下五个区域：程序计数器，Java虚拟机栈，本地方法栈，堆，方法区（其中前三个区域各线程私有，相互独立，后面两个区域所有线程共享）
![](../static/16f98e68c8fed611.png)

### 线程私用的部分(Java虚拟机栈,本地方法栈,程序计数器)

#### Java虚拟机栈

执行一个Java方法时，虚拟机都会创建一个栈帧，来存储局部变量表，操作数栈等，方法调用完毕后会对栈帧从虚拟机栈中移除。

局部变量表中存储了Java基本类型，对象引用（可以是对象的存储地址，也可以是代表对象的句柄等）和returnAddress类型（存储了一条字节码指令的地址）。
##### 本地方法栈 
本地方法栈与Java虚拟机栈类似，只不过是执行Native方法（C++方法等）。

#### 程序计数器
计数器存储了当前线程正在执行的字节码指令的地址（如果是当前执行的是Native方法，那么计数器为空），字节码解释器就是通过改变计数器的值来选取下一条需要执行的字节码指令。程序计数器是线程私有的，便于各个线程切换后，可以恢复到正确的执行位置。

### 线程共享的部分(堆,方法区)
#### Java 堆

堆存储了几乎所有对象实例和数组，是被所有线程进行共享的区域。在逻辑上是连续的，在物理上可以是不连续的内存空间（在存储一些类似于数组的这种大对象时，基于简单和性能考虑会使用连续的内存空间）。

#### 方法区
存储了被虚拟机加载的类型信息，常量，静态变量等数据，在JDK8以后，存储在元空间中（以前是存储在堆中的永久代中，JDK8以后已经没有永久代了）。

运行时常量池是方法区的一部分，会存储各种字面量和符号引用。具备动态性，运行时也可以添加新的常量入池（例如调用String的intern()方法时，如果常量池没有相应的字符串，会将它添加到常量池）。


### 直接内存区(不属于虚拟机运行时数据区)
直接内存区不属于虚拟机运行时数据区的一部分。它指的是使用Native方法直接分配堆外内存，然后通过Java堆中的DirectByteBuffer来对内存的引用进行操作（可以避免Java堆与Native堆之间的数据复制，提升性能）。

### 2.3 HotSpot虚拟机对象探秘
### 对象的创建过程

这是网上看到的一张流程图：

![java对象创建流程](../static/20160505123459787.jpeg)

#### 1.类加载检查
当虚拟机遇到一条字节码**new**指令时，会根据类名去**常量池**找类的**符号引用**，检查符号引用代表的类是否已加载，解析和初始化过。如果没有就执行相应的**类加载**过程。

#### 2.分配内存
虚拟机从Java堆中分配一块大小确定的内存（因为类加载时，创建一个此类的实例对象的所需的内存大小就确定了），并且初始化为零值。内存分配的方式有**指针碰撞**和**空闲列表**两种，取决于虚拟机采用的垃圾回收期是否带有空间压缩整理的功能。

##### 指针碰撞

如果垃圾收集器是Serial，ParNew等带有空间压缩整理的功能时，Java堆是规整的，此时通过移动内存分界点的指针，就可以分配空闲内存。

##### 空闲列表

如果垃圾收集器是CMS这种基于清除算法的收集器时，Java堆中的空闲内存和已使用内存是相互交错的，虚拟机会维护一个列表，记录哪些可用，哪些不可用，分配时从表中找到一块足够大的空闲内存分配给实例对象，并且更新表。

#### PS:如何解决内存分配时的多线程并发竞争问题？
内存分配不是一个线程安全的操作，在多个线程进行内存分配是，可能会存在数据不同步的问题。所以有两种方法解决：
##### 添加CAS锁
对内存分配的操作进行同步处理，添加CAS锁，配上失败重试的方式来保证原子性。（默认使用这种方式）。
##### 预先给各线程分配TLAB
预先在Java堆中给各个线程分配一块TLAB（本地线程缓冲区）内存，每个线程先在各自的缓冲区中分配内存，使用完了再通过第一种添加CAS锁的方式来分配内存。（是否启动取决于-XX：+/-UseTLAB参数）。

#### 3.对象初始化（虚拟机层面）
虚拟机会对对象进行必要的设置，将对象的一些信息存储在Obeject header 中。

#### 4.对象初始化（Java程序层面）
在构造一个类的实例对象时，在Java程序层面会依次进行以下操作：
* 初始化父类的静态变量（如果是首次使用此类）
* 初始化子类的静态变量（如果是首次使用此类）
* 执行父类的静态代码块（如果是首次使用此类）
* 执行子类的静态代码块（如果是首次使用此类）
* 初始化父类的实例变量
* 初始化子类的实例变量
* 执行父类的普通代码块
* 执行子类的普通代码块
* 执行父类的构造器
* 执行子类的构造器

###  对象的内存布局

对象在内存中存储布局主要分为对象头，实例数据和对齐填充三部分。

这是网上看到的一张图：

![5401975-4c082ac80e1c042c](../static/5401975-4c082ac80e1c042c.png)

#### 对象头

对象头主要包含对象自身的运行时数据(也就是图中Mark Word)，类型指针(图中的Class Pointer，指向对象所属的类)。如果对象是数组，还需要包含数组长度(否则无法确定数组对象的大小)。

**Mark Word**：存储对象自身的运行时数据，例如hashCode，GC分代年龄，锁状态标志，线程持有的锁等等。在32位系统占4字节，在64位系统中占8字节。

 **Class Pointer**：用来指向对象对应的Class对象（其对应的元数据对象）的内存地址。在32位系统占4字节，在64位系统中占8字节。

 **Length**：如果是数组对象，还有一个保存数组长度的空间，占4个字节。

#### 实例数据

保存对象的非静态成员变量数据。

#### 对齐填充

因为HotSpot虚拟机的自动内存管理系统要求对象起始地址是8字节的整数倍，所以任何对象的大小必须是8字节的整数倍，而对象头部分一般是8字节的倍数，如果实力数据部分不是8字节的整数倍，需要对齐填充来补全。

#### 对象的访问定位

根据对象的引用去访问的对象的方式有通过句柄访问和之间指针访问两种。

* 通过句柄访问

  Java堆中有一块内存作为句柄池，每个句柄包含了对象的实例数据地址和类数据地址，对象的引用保存的是句柄地址，通过句柄再去访问对象。这种方式的好处是在垃圾回收时，移动对象时，对象的引用保存的地址不用变化，只需要改变句柄中保存的实例数据地址。

* 直接指针访问(HotSpot虚拟机的主要使用方式)

  这种方式，对象引用保存的地址是对象的地址，根据对象引用可以直接访问对象，节省了一次指针定位的时间开销，速度更快。

## 第3章 垃圾收集器和内存分配策略
因为程序计数器，虚拟机栈，本地方法栈都是线程私有的，生命周期与线程相同，当方法执行完或者线程结束时，内存就回收了，所以这三个内存区域的内存回收具备确定性，而堆和方法区的内存回收存在不确定性，所以需要垃圾收集器进行管理。
### 垃圾回收的几种算法
#### 引用计数法
每个对象有一个引用计数，当其他对象引用这个对象时，该对象的引用计数+1，当其他对象不再引用这个对象时，引用计数-1。当引用计数为0时，垃圾回收器可以对对象进行回收。

缺点在于需要大量额外处理才能保证正确地工作，例如单纯的引用计数没有办法解决循环引用的问题。

#### 可达性分析算法

根据一系列GC Roots对象作为起始点，从这些节点根据引用关系向下搜索，走过的路径是引用链，如果一个对象没有被任何引用链相连，说明是不可达的，也就是不可能被使用的，会被判定为可回收的对象。


GC Roots对象只有包括以下几种：

* 虚拟机栈(栈帧中的本地变量表)引用的对象。例如方法的传参，局部变量等。

* 方法区中类的静态变量引用的对象。

* 方法区中常量引用的对象。例如字符串常量池中的引用。

* 本地方法栈中的引用的对象。

* Java虚拟机内部的引用，例如基本数据类型对应的Class对象，常驻的异常对象（NullPointException等）

* 被同步锁（sychronized关键字修饰）持有的对象。

  除此以外，根据用户所选用的垃圾回收器以及当前回收的内存区域的不同，还可以将其他对象临时性加入，共同构成GC Roots集合，辅助内存回收。（例如回收新生代内存时，可以将一些关联区域的对象一并加入GC Roots集合中去。）

### 对象的强引用，软引用，弱引用和虚引用

##### 强引用

  就是普通的变量对对象的引用，强引用的对象不会被系统回收。

  ##### 软引用

  当内存空间足够时，软引用的对象不会被系统回收。当内存空间不足时，软引用的对象可能被系统回收。通常用于内存敏感的程序中。

  ##### 弱引用

  引用级别比软引用低，对于只有软引用的对象，不管内存是否足够， 都可能会被系统回收。

  ##### 虚引用

  虚引用主要用于跟踪对象被垃圾回收的状态，不能单独使用，必须和引用队列联合使用。

##### finalize()方法

第一次标记

垃圾回收器对对象进行可达性分析之后，发现没有任何于GCRoots连接的引用链引用着对象，会将对象进行**第一次标记**，

第二次标记

* 如果对象有覆写finalize()方法

  会将对象添加到F-Queue队列中，让由一条虚拟机创建的、低调度优先级的线程去执行finalize()方法（不一定会等待运行结束，防止其他对象处于长时间的等待）。如果在finalize方法中，成功得让对象与引用链上的人格对象简历了关联，那么会被移除“即将回收”的集合，否则会被**第二次标记**。

* 如果对象没有覆写finalize()方法，或者finalize()方法已被调用，那么会对对象进行**第二次标记**，稍后对象会被回收。

#### 回收方法区

回收方法区主要是回收不再使用的常量和不再使用的类型。

不再使用的类型需要满足三个条件：

* 类的所有的实例都已被回收。
* 加载此类的类加载器已被回收。
* 类的方法无法再通过反射调用。(类对应的java.lang.Class对象没有在任何地方被引用。）

## 垃圾回收算法

**弱分代假说**

绝对大多数对象都是朝生夕灭。

**强分代假说**

熬过月多次垃圾收集过程的对象就越难以消灭。

基于这两个假说，Java虚拟机一般会分为新生代和老年代，然后根据区域内对象的特性，采用不通的垃圾回收算法。

垃圾回收算法一般有四种

![1581500802565](../static/1581500802565.jpg)

**标记-清除算法**

就是对要回收的对象进行标记，标记完成后统一回收。

缺点：

1.执行效率不稳定，有大量对象时，并且有大量对象需要回收时，执行效率会降低。

2.内存碎片化，会产生大量不连续的内存碎片。

#### 标记-复制算法

就是将内存分为两块，每次只用其中一块，垃圾回收时将存活对象，拷贝到另一块内存。

缺点：

1.存活率较高时需要很多复制操作，销量会降低。

2.会浪费一半的内存，

解决方案是新生代的内存配比是Eden:From Survivor: To Survivor = 8:1:1

每次只使用Eden和From Survivor的空间，将存活对象拷贝到To Survivor，当空间不够时，从老年代进行分配担保。

####标记-整理算法

让存活对象往内存空间一端移动，然后直接清理掉边界以外的内存。

#### 分代收集算法

新生代存活率低，使用标记复制算法。

老年代存活率高，使用标记-清除算法，或者标记-整理算法。

